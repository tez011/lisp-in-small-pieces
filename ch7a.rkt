#lang racket

; A compiler that emits callable thunks, which invoke instructions to a virtual machine.
; The instructions are encoded as combinators.

; Variable classification.
(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n)))
(define (local-variable? r i n)
  (and (pair? r) ; and C T === if C T #f
       (let scan ((names (car r)) (j 0))
         (cond ((pair? names)
                (if (eq? n (car names))
                    (cons 'local (cons i j))
                    (scan (cdr names) (+ 1 j))))
               ((null? names)
                (local-variable? (cdr r) (+ i 1) n))
               ((eq? n names) (cons 'local (cons i j)))))))
(define (global-variable? g n)
  (let ((var (assq n g)))
    (and (pair? var) (cdr var))))

; The environment and store.
(struct environment (next) #:mutable)
(struct activation-frame environment (arguments) #:mutable)
(struct closure (code closed-environment) #:constructor-name make-closure)
(define (allocate-activation-frame argsize)
  (activation-frame '()
                    (make-vector argsize)))
(define (activation-frame-argument-length sr)
  (vector-length (activation-frame-arguments sr)))
(define (activation-frame-argument sr i)
  (vector-ref (activation-frame-arguments sr) i))
(define (set-activation-frame-argument! sr i v)
  (vector-set! (activation-frame-arguments sr) i v))

; Registers and operations on registers
(define *pc* '())
(define *env* '())
(define *val* '())
(define *fun* '())
(define *arg1* '())
(define *arg2* '())
(define *exit* #f)
(define *stack* (make-vector 1000))
(define *stack-index* 0)
(define (stack-push v)
  (vector-set! *stack* *stack-index* v)
  (set! *stack-index* (+ *stack-index* 1)))
(define (stack-pop)
  (set! *stack-index* (- *stack-index* 1))
  (vector-ref *stack* *stack-index*))
(define (save-stack)
  (let ((copy (make-vector *stack-index*)))
    (vector-copy! *stack* copy 0 *stack-index*)
    copy))
(define (restore-stack copy)
  (set! *stack-index* (vector-length copy))
  (vector-copy! copy *stack* 0 *stack-index*))
(define (vector-copy! src dst start end)
  (let copy ((i start))
    (when (< i end)
      (vector-set! dst i (vector-ref src i))
      (copy (+ i 1)))))
(struct primitive (address))
(struct continuation (stack))

; Environment and store
(define r.init '())
(define sr.init '())
(define (r-extend* r n*) (cons n* r))
(define (sr-extend* sr v*)
  (set-environment-next! v* sr)
  v*)
(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j)))
(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v)))

(define g.current '())
(define sg.current (make-vector 100))
(define (g.current-extend! n)
  (let ((level (length g.current)))
    (set! g.current (cons (cons n (cons 'global level)) g.current))
    level))
(define (global-fetch i)
  (vector-ref sg.current i))
(define (global-update! i v)
  (vector-set! sg.current i v))
(define (g.current-initialize! name)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((global) (vector-set! sg.current (cdr kind) undefined-value))
          (else (static-wrong "incorrect redefinition" name))) ; don't allow this function to modify predefined values (which are in sg.init not sg.current anyway)
        (let ((index (g.current-extend! name)))
          (vector-set! sg.current index undefined-value))))
  name)
(define undefined-value '(undefined value))

(define g.init '())
(define sg.init (make-vector 100))
(define (g.init-extend! n)
  (let ((level (length g.init)))
    (set! g.init (cons (cons n (cons 'predefined level)) g.init))
    level))
(define (predefined-fetch i)
  (vector-ref sg.init i))
(define (g.init-initialize! name value)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((predefined) (vector-set! sg.init (cdr kind) value))
          (else (static-wrong "incorrect redefinition" name))) ; don't allow this function to modify global values (which are in sg.current not sg.init anyway)
        (let ((index (g.init-extend! name)))
          (vector-set! sg.init index value))))
  name)

; The descriptor environment. This defines the arity of global immutable functions so those checks can be done at compile time.
(define desc.init '())
(define (description-extend! name description)
  (set! desc.init (cons (cons name description) desc.init))
  name)
(define (get-description name)
  (let ((p (assq name desc.init)))
    (and (pair? p) (cdr p))))

; The compiler.
(define (static-wrong message . culprits)
  (display (cons 'STATIC-ERROR (cons message culprits))) (newline) ; display the error
  (lambda () 
    (apply wrong message culprits))) ; and only invoke 'wrong' if the erroneous block is evaluated; if it's skipped, no harm no foul!
(define (meaning e r tail?)
  (if (pair? e)
      (case (car e)
        ((quote) (meaning-quotation (cadr e) r tail?))
        ((if) (meaning-alternative (cadr e) (caddr e) (cadddr e) r tail?))
        ((begin) (meaning-sequence (cdr e) r tail?))
        ((set!) (meaning-assignment (cadr e) (caddr e) r tail?))
        ((lambda) (meaning-abstraction (cadr e) (cddr e) r tail?))
        (else (meaning-application (car e) (cdr e) r tail?)))
      (if (symbol? e)
          (meaning-reference e r tail?)
          (meaning-quotation e r tail?))))
(define (meaning-quotation v r tail?)
  (CONSTANT v))
(define (meaning-reference n r tail?)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local) (let ((i (cadr kind))
                         (j (cddr kind)))
                     (if (= i 0)
                         (SHALLOW-ARGUMENT-REF j) ; This optimization was omitted in LiSP6a.
                         (DEEP-ARGUMENT-REF i j))))
          ((global) (let ((i (cdr kind)))
                      (CHECKED-GLOBAL-REF i n)))
          ((predefined) (let ((i (cdr kind))) (PREDEFINED i))))
        (static-wrong "no such variable" n))))
(define (meaning-alternative ec et ef r tail?)
  (let ((mc (meaning ec r #f)) ; the condition is definitely NOT in tail position
        (mt (meaning et r tail?))
        (mf (meaning ef r tail?)))
    (ALTERNATIVE mc mt mf)))
(define (meaning-sequence e* r tail?)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (meaning*-multiple-sequence (car e*) (cdr e*) r tail?)
          (meaning (car e*) r tail?))
      (static-wrong "illegal syntax: (begin)")))
(define (meaning*-multiple-sequence e e* r tail?)
  (let ((m (meaning e r #f))
        (m* (meaning-sequence e* r tail?)))
    (SEQUENCE m m*)))
(define (meaning-assignment n e r tail?)
  (let ((m (meaning e r #f))
        (kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local) (let ((i (cadr kind))
                         (j (cddr kind)))
                     (if (= i 0)
                         (SHALLOW-ARGUMENT-SET! j m)
                         (DEEP-ARGUMENT-SET! i j m))))
          ((global) (let ((i (cdr kind)))
                      (GLOBAL-SET! i m)))
          ((predefined) (static-wrong "immutable predefined variable" n)))
        (static-wrong "no such variable" n))))
(define (meaning-abstraction nn* e* r tail?)
  (let next-parameter ((n* nn*) (accumulator '()))
    (cond ((pair? n*) (next-parameter (cdr n*) (cons (car n*) accumulator)))
          ((null? n*) (meaning-fix-abstraction nn* e* r tail?))
          (else (meaning-dotted-abstraction (reverse accumulator) n* e* r tail?)))))
(define (meaning-fix-abstraction n* e* r tail?)
  (let* ((arity (length n*))
         (r2 (r-extend* r n*))
         (m* (meaning-sequence e* r2 #t)))
    (FIX-CLOSURE m* arity)))
(define (meaning-dotted-abstraction n n* e* r tail?)
  (let* ((arity (length n*))
         (r2 (r-extend* r (append n* (list n))))
         (m* (meaning-sequence e* r2 #t)))
    (NARY-CLOSURE m* arity)))
(define (listify! v* arity)
  (let loop ((index (- (activation-frame-argument-length v*) 1)) ; the desired index is the last box in the set
             (result '()))
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1)) result)))))
(define (meaning-application e e* r tail?)
  (cond ((and (symbol? e)
              (let ((kind (compute-kind r e)))
                (and (pair? kind)
                     (eq? 'predefined (car kind))
                     (let ((desc (get-description e)))
                       (and desc
                            (eq? 'function (car desc))
                            (or (= (cddr desc) (length e*))
                                (static-wrong "incorrect arity for primitive" e)))))))
         (meaning-primitive-application e e* r tail?))
        ((and (pair? e)
              (eq? 'lambda (car e)))
         (meaning-closed-application e e* r tail?))
        (else (meaning-regular-application e e* r tail?))))
(define (meaning-regular-application e e* r tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r (length e*) #f)))
    (if tail? (TR-REGULAR-CALL m m*) (REGULAR-CALL m m*))))
(define (meaning* e* r size tail?)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size tail?)
      (meaning-no-arguments r size tail?)))
(define (meaning-some-arguments e e* r size tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r size tail?))
        (rank (- size (+ (length e*) 1))))
    (STORE-ARGUMENT m m* rank)))
(define (meaning-no-arguments r size tail?)
  (ALLOCATE-FRAME size))
(define (meaning-closed-application e ee* r tail?)
  (let ((nn* (cadr e)))
    (let next-parameter ((n* nn*) (e* ee*) (accumulator '()))
      (cond ((pair? n*)
             (if (pair? e*)
                 (next-parameter (cdr n*) (cdr e*) (cons (car n*) accumulator))
                 (static-wrong "too few arguments" e ee*)))
            ((null? n*)
             (if (null? e*)
                 (meaning-fix-closed-application nn* (cddr e) ee* r tail?)
                 (static-wrong "too many arguments" e ee*)))
            (else (meaning-dotted-closed-application (reverse accumulator) n* (cddr e) ee* r tail?))))))
(define (meaning-fix-closed-application n* body e* r tail?)
  (let* ((m* (meaning* e* r (length e*) #f))
         (r2 (r-extend* r n*))
         (mt (meaning-sequence body r2 tail?)))
    (if tail? (TR-FIX-LET m* mt) (FIX-LET m* mt))))
(define (meaning-dotted-closed-application n* n body e* r tail?)
  (let* ((m* (meaning-dotted* e* r (length e*) (length n*) #f))
         (r2 (r-extend* r (append n* (list n))))
         (mt (meaning-sequence body r2 tail?)))
    (if tail? (TR-FIX-LET m* mt) (FIX-LET m* mt))))
(define (meaning-dotted* e* r size arity tail?)
  (if (pair? e*)
      (meaning-some-dotted-arguments (car e*) (cdr e*) r size arity tail?)
      (meaning-no-dotted-arguments r size arity tail?)))
(define (meaning-some-dotted-arguments e e* r size arity tail?)
  (let ((m (meaning e r #f))
        (m* (meaning-dotted* e* r size arity tail?))
        (rank (- size (+ (length e*) 1))))
    (if (< rank arity)
        (STORE-ARGUMENT m m* rank)
        (CONS-ARGUMENT m m* arity))))
(define (meaning-no-dotted-arguments r size arity tail?)
  (ALLOCATE-DOTTED-FRAME arity))
(define (meaning-primitive-application e e* r tail?)
  (let* ((desc (get-description e))
         (address (cadr desc))
         (size (length e*)))
    (case size
      ((0) (CALL0 address))
      ((1) (let ((m1 (meaning (car e*) r #f)))
             (CALL1 address m1)))
      ((2) (let ((m1 (meaning (car e*) r #f))
                 (m2 (meaning (cadr e*) r #f)))
             (CALL2 address m1 m2)))
      ((3) (let ((m1 (meaning (car e*) r #f))
                 (m2 (meaning (cadr e*) r #f))
                 (m3 (meaning (caddr e*) r #f)))
             (CALL3 address m1 m2 m3)))
      (else (meaning-regular-application e e* r tail?)))))

; The virtual machine.
(define (CONSTANT value)
  (list (lambda () (set! *val* value))))
(define (SHALLOW-ARGUMENT-REF i)
  (list (lambda () (set! *val* (activation-frame-argument *env* i)))))
(define (DEEP-ARGUMENT-REF i j)
  (list (lambda () (set! *val* (deep-fetch *env* i j)))))
(define (GLOBAL-REF i)
  (list (lambda () (set! *val* (global-fetch i)))))
(define (CHECKED-GLOBAL-REF i n)
  (list (lambda ()
          (set! *val* (global-fetch i))
          (when (eq? *val* undefined-value) (wrong "uninitialized variable" n)))))
(define (PREDEFINED i)
  (list (lambda () (set! *val* (predefined-fetch i)))))
(define (ALTERNATIVE mc mt mf)
  (append mc
          (JUMP-FALSE (+ 1 (length mt)))
          mt
          (GOTO (length mf))
          mf))
(define (JUMP-FALSE i)
  (list (lambda () (unless *val* (set! *pc* (list-tail *pc* i))))))
(define (GOTO i)
  (list (lambda () (set! *pc* (list-tail *pc* i)))))
(define (SHALLOW-ARGUMENT-SET! i m)
  (append m (SET-SHALLOW-ARGUMENT! i)))
(define (SET-SHALLOW-ARGUMENT! i)
  (list (lambda () (set-activation-frame-argument! *env* i *val*))))
(define (DEEP-ARGUMENT-SET! i j m)
  (append m (SET-DEEP-ARGUMENT! i j)))
(define (SET-DEEP-ARGUMENT! i j)
  (list (lambda () (deep-update! *env* i j *val*))))
(define (GLOBAL-SET! i m)
  (append m (SET-GLOBAL! i)))
(define (SET-GLOBAL! i)
  (list (lambda () (global-update! i *val*))))
(define (SEQUENCE m m*)
  (append m m*))
(define (FIX-CLOSURE m* arity)
  (define the-function
    (append (ARITY=? (+ arity 1))
            (EXTEND-ENV)
            m*
            (RETURN)))
  (append (CREATE-CLOSURE 1)
          (GOTO (length the-function))
          the-function))
(define (NARY-CLOSURE m* arity)
  (define the-function
    (append (ARITY>=? (+ arity 1))
            (PACK-FRAME! arity)
            (EXTEND-ENV)
            m*
            (RETURN)))
  (append (CREATE-CLOSURE 1)
          (GOTO (length the-function))
          the-function))
(define (ARITY=? arity+1)
  (list (lambda () (unless (= (activation-frame-argument-length *val*) arity+1)
                     (wrong "incorrect arity")))))
(define (ARITY>=? arity+1)
  (list (lambda () (unless (>= (activation-frame-argument-length *val*) arity+1)
                     (wrong "incorrect arity")))))
(define (CREATE-CLOSURE offset)
  (list (lambda () (set! *val* (make-closure (list-tail *pc* offset) *env*)))))
(define (PACK-FRAME! arity)
  (list (lambda () (listify! *val* arity))))
(define (TR-REGULAR-CALL m m*)
  (append m
          (PUSH-VALUE)
          m*
          (POP-FUNCTION)
          (FUNCTION-INVOKE)))
(define (REGULAR-CALL m m*)
  (append m
          (PUSH-VALUE)
          m*
          (POP-FUNCTION)
          (PRESERVE-ENV)
          (FUNCTION-INVOKE)
          (RESTORE-ENV)))
(define (PUSH-VALUE)
  (list (lambda () (stack-push *val*))))
(define (POP-FUNCTION)
  (list (lambda () (set! *fun* (stack-pop)))))
(define (PRESERVE-ENV)
  (list (lambda () (stack-push *env*))))
(define (FUNCTION-INVOKE)
  (list (lambda () (invoke *fun*))))
(define (RESTORE-ENV)
  (list (lambda () (set! *env* (stack-pop)))))
(define (STORE-ARGUMENT m m* rank)
  (append m
          (PUSH-VALUE)
          m*
          (POP-FRAME! rank)))
(define (POP-FRAME! rank)
  (list (lambda () (set-activation-frame-argument! *val* rank (stack-pop)))))
(define (ALLOCATE-FRAME size)
  (let ((size+1 (+ size 1)))
    (list (lambda () (set! *val* (allocate-activation-frame size+1))))))
(define (FIX-LET m* mt)
  (append m*
          (EXTEND-ENV)
          mt
          (UNLINK-ENV)))
(define (EXTEND-ENV)
  (list (lambda () (set! *env* (sr-extend* *env* *val*)))))
(define (UNLINK-ENV)
  (list (lambda () (set! *env* (environment-next *env*)))))
(define (TR-FIX-LET m* mt)
  (append m*
          (EXTEND-ENV)
          mt))
(define (CONS-ARGUMENT m m* arity)
  (append m
          (PUSH-VALUE)
          m*
          (POP-CONS-FRAME! arity)))
(define (POP-CONS-FRAME! arity)
  (list (lambda () (set-activation-frame-argument!
                    *val*
                    arity
                    (cons (stack-pop)
                          (activation-frame-argument *val* arity))))))
(define (ALLOCATE-DOTTED-FRAME arity)
  (let ((arity+1 (+ arity 1)))
    (list (lambda ()
      (let ((v* (allocate-activation-frame arity+1)))
        (set-activation-frame-argument! v* arity '())
        (set! *val* v*))))))
(define (CALL0 address)
  (list (lambda () (set! *val* (address)))))
(define (CALL1 address m1)
  (append m1
          (INVOKE1 address)))
(define (CALL2 address m1 m2)
  (append m1
          (PUSH-VALUE)
          m2
          (POP-ARG1)
          (INVOKE2 address)))
(define (CALL3 address m1 m2 m3)
  (append m1
          (PUSH-VALUE)
          m2
          (PUSH-VALUE)
          (POP-ARG2)
          (POP-ARG1)
          (INVOKE3 address)))
(define (POP-ARG1)
  (list (lambda () (set! *arg1* (stack-pop)))))
(define (POP-ARG2)
  (list (lambda () (set! *arg1* (stack-pop)))))
(define (INVOKE1 address)
  (list (lambda () (set! *val* (address *val*)))))
(define (INVOKE2 address)
  (list (lambda () (set! *val* (address *arg1* *val*)))))
(define (INVOKE3 address)
  (list (lambda () (set! *val* (address *arg1* *arg2* *val*)))))
(define (RETURN)
  (list (lambda () (set! *pc* (stack-pop)))))
(define (FINISH)
  (list (lambda () (*exit* *val*))))

(define (invoke f)
  (cond ((closure? f)
         (stack-push *pc*)
         (set! *env* (closure-closed-environment f))
         (set! *pc* (closure-code f)))
        ((primitive? f)
         ((primitive-address f)))
        ((continuation? f)
         (if (= (+ 1 1) (activation-frame-argument-length *val*))
             (begin
               (restore-stack (continuation-stack f))
               (set! *val* (activation-frame-argument *val* 0))
               (set! *pc* (stack-pop)))
             (wrong "incorrect arity" 'continuation)))
        (else (wrong "not a function" f))))
(define (run)
  (let ((instruction (car *pc*)))
    (set! *pc* (cdr *pc*))
    (instruction)
    (run)))

; The contents of the environment.
(define-syntax definition
  (syntax-rules ()
    ((definition name value)
     (g.init-initialize! 'name value))))
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value 0) (defprimitive0 name value))
    ((defprimitive name value 1) (defprimitive1 name value))
    ((defprimitive name value 2) (defprimitive2 name value))
    ((defprimitive name value 3) (defprimitive3 name value))))
(define-syntax defprimitive0
  (syntax-rules ()
    ((defprimitive0 name value)
     (definition name
       (letrec ((arity+1 (+ 0 1))
                (behavior (lambda ()
                            (if (= (activation-frame-argument-length *val*) arity+1)
                                (set! *val* (value))
                                (wrong "incorrect arity" (cons 'name 0))))))
         (description-extend! 'name (cons 'function (cons value 0)))
         (primitive behavior))))))
(define-syntax defprimitive1
  (syntax-rules ()
    ((defprimitive1 name value)
     (definition name
       (letrec ((arity+1 (+ 1 1))
                (behavior (lambda ()
                            (if (= (activation-frame-argument-length *val*) arity+1)
                                (set! *val* (value (activation-frame-argument *val* 0)))
                                (wrong "incorrect arity" (cons 'name 1))))))
         (description-extend! 'name (cons 'function (cons value 1)))
         (primitive behavior))))))
(define-syntax defprimitive2
  (syntax-rules ()
    ((defprimitive2 name value)
     (definition name
       (letrec ((arity+1 (+ 2 1))
                (behavior (lambda ()
                            (if (= (activation-frame-argument-length *val*) arity+1)
                                (set! *val* (value (activation-frame-argument *val* 0)
                                                   (activation-frame-argument *val* 1)))
                                (wrong "incorrect arity" (cons 'name 2))))))
         (description-extend! 'name (cons 'function (cons value 2)))
         (primitive behavior))))))
(define-syntax defprimitive3
  (syntax-rules ()
    ((defprimitive3 name value)
     (definition name
       (letrec ((arity+1 (+ 3 1))
                (behavior (lambda ()
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (set! *val* (value (activation-frame-argument v* 0)
                                                   (activation-frame-argument v* 1)
                                                   (activation-frame-argument v* 2)))
                                (wrong "incorrect arity" (cons 'name 3))))))
         (description-extend! 'name (cons 'function (cons value 3)))
         (primitive behavior))))))
(define-syntax defvariable
  (syntax-rules ()
    ((defvariable name) (g.current-initialize! 'name))))

(definition true #t)
(definition false #f)
(definition nil '())
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive cdr cdr 1)
(defprimitive pair? pair? 1)
(defprimitive symbol? symbol? 1)
(defprimitive eq? eq? 2)
(defprimitive set-car! set-mcar! 2)
(defprimitive set-cdr! set-mcdr! 2)
(defprimitive + + 2)
(defprimitive - - 2)
(defprimitive = = 2)
(defprimitive < < 2)
(defprimitive > > 2)
(defprimitive * * 2)
(defprimitive <= <= 2)
(defprimitive >= >= 2)
(defprimitive remainder remainder 2)
(defprimitive display display 1)
(definition call/cc
  (let* ((arity 1)
         (arity+1 (+ arity 1)))
    (primitive (lambda ()
                 (if (= (activation-frame-argument-length *val*) arity+1)
                     (let ((f (activation-frame-argument *val* 0))
                           (frame (allocate-activation-frame arity+1)))
                       (stack-push *pc*)
                       (set-activation-frame-argument! frame 0 (continuation (save-stack)))
                       (stack-pop)
                       (set! *val* frame)
                       (invoke f))
                     (wrong "incorrect arity" 'call/cc))))))
(definition apply
  (let* ((arity 2)
         (arity+1 (+ arity 1)))
    (primitive (lambda ()
                 (if (>= (activation-frame-argument-length *val*) arity+1)
                     (let* ((proc (activation-frame-argument *val* 0))
                            (last-arg-index (- (activation-frame-argument-length *val*) 2))
                            (last-arg (activation-frame-argument *val* last-arg-index))
                            (size (+ last-arg-index (length last-arg)))
                            (frame (allocate-activation-frame size)))
                       (do ((i 1 (+ i 1))) ((= i last-arg-index))
                         (set-activation-frame-argument! frame (- i 1) (activation-frame-argument *val* i)))
                       (do ((i (- last-arg-index 1) (+ i 1)) (last-arg last-arg (cdr last-arg))) ((null? last-arg))
                         (set-activation-frame-argument! frame i (car last-arg)))
                       (set! *val* frame)
                       (invoke proc))
                     (wrong "incorrect arity" 'apply))))))
(definition list
  (primitive (lambda ()
               (let ((argc (- (activation-frame-argument-length *val*) 1))
                     (result '()))
                 (do ((i argc (- i 1))) ((= i 0))
                   (set! result (cons (activation-frame-argument *val* (- i 1)) result)))
                 (set! *val* result)))))

(defvariable x)
(defvariable y)
(defvariable z)
(defvariable a)
(defvariable b)
(defvariable c)
(defvariable foo)
(defvariable bar)
(defvariable fib)
(defvariable fact)
(define wrong #f)
(call-with-current-continuation (lambda (k)
                                  (set! wrong (lambda args (display ">>>> EVALUATION ERROR") (newline) (k args)))))
  
(define (LiSP7a)
  (define (toplevel)
    (define e (read))
    (set! *env* sr.init)
    (set! *val* #f)
    (set! *fun* #f)
    (set! *arg1* #f)
    (set! *arg2* #f)
    (set! *stack-index* 0)
    (set! *pc* (append (meaning e r.init #t)
                       (FINISH)))
    (call-with-current-continuation (lambda (exit)
                                      (set! *exit* exit)
                                      (run)))
    (display *val*)
    (newline)
    (toplevel))
  (toplevel))

(LiSP7a)
#|
((lambda (fact) (fact 5 fact (lambda (x) x)))
   (lambda (n f k) (if (= n 0) (k 1) (f (- n 1) f (lambda (r) (k (* n r)))))))
|#