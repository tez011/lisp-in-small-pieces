#lang racket

; A compiler that emits callable thunks, which invoke instructions to a virtual machine.
; The instructions are encoded as combinators.

; Variable classification.
(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n)))
(define (local-variable? r i n)
  (and (pair? r) ; and C T === if C T #f
       (let scan ((names (car r)) (j 0))
         (cond ((pair? names)
                (if (eq? n (car names))
                    (cons 'local (cons i j))
                    (scan (cdr names) (+ 1 j))))
               ((null? names)
                (local-variable? (cdr r) (+ i 1) n))
               ((eq? n names) (cons 'local (cons i j)))))))
(define (global-variable? g n)
  (let ((var (assq n g)))
    (and (pair? var) (cdr var))))

; The environment and store.
(struct environment (next) #:mutable)
(struct activation-frame environment (arguments) #:mutable)
(struct closure (code closed-environment) #:constructor-name make-closure)
(define (allocate-activation-frame argsize)
  (activation-frame '()
                    (make-vector argsize)))
(define (activation-frame-argument-length sr)
  (vector-length (activation-frame-arguments sr)))
(define (activation-frame-argument sr i)
  (vector-ref (activation-frame-arguments sr) i))
(define (set-activation-frame-argument! sr i v)
  (vector-set! (activation-frame-arguments sr) i v))

(define *env* '())
(define r.init '())
(define sr.init '())
(define (r-extend* r n*) (cons n* r))
(define (sr-extend* sr v*)
  (set-environment-next! v* sr)
  v*)
(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j)))
(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v)))

(define g.current '())
(define sg.current (make-vector 100))
(define (g.current-extend! n)
  (let ((level (length g.current)))
    (set! g.current (cons (cons n (cons 'global level)) g.current))
    level))
(define (global-fetch i)
  (vector-ref sg.current i))
(define (global-update! i v)
  (vector-set! sg.current i v))
(define (g.current-initialize! name)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((global) (vector-set! sg.current (cdr kind) undefined-value))
          (else (static-wrong "incorrect redefinition" name))) ; don't allow this function to modify predefined values (which are in sg.init not sg.current anyway)
        (let ((index (g.current-extend! name)))
          (vector-set! sg.current index undefined-value))))
  name)
(define undefined-value '(undefined value))

(define g.init '())
(define sg.init (make-vector 100))
(define (g.init-extend! n)
  (let ((level (length g.init)))
    (set! g.init (cons (cons n (cons 'predefined level)) g.init))
    level))
(define (predefined-fetch i)
  (vector-ref sg.init i))
(define (g.init-initialize! name value)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((predefined) (vector-set! sg.init (cdr kind) value))
          (else (static-wrong "incorrect redefinition" name))) ; don't allow this function to modify global values (which are in sg.current not sg.init anyway)
        (let ((index (g.init-extend! name)))
          (vector-set! sg.init index value))))
  name)

(define (invoke f v*)
  (if (closure? f)
      ((closure-code f) v* (closure-closed-environment f))
      (wrong "not a function" f)))

; The descriptor environment. This defines the arity of global immutable functions so those checks can be done at compile time.
(define desc.init '())
(define (description-extend! name description)
  (set! desc.init (cons (cons name description) desc.init))
  name)
(define (get-description name)
  (let ((p (assq name desc.init)))
    (and (pair? p) (cdr p))))

; The compiler.
(define (static-wrong message . culprits)
  (display (cons 'STATIC-ERROR (cons message culprits))) (newline) ; display the error
  (lambda () 
    (apply wrong message culprits))) ; and only invoke 'wrong' if the erroneous block is evaluated; if it's skipped, no harm no foul!
(define (meaning e r tail?)
  (if (pair? e)
      (case (car e)
        ((quote) (meaning-quotation (cadr e) r tail?))
        ((if) (meaning-alternative (cadr e) (caddr e) (cadddr e) r tail?))
        ((begin) (meaning-sequence (cdr e) r tail?))
        ((set!) (meaning-assignment (cadr e) (caddr e) r tail?))
        ((lambda) (meaning-abstraction (cadr e) (cddr e) r tail?))
        (else (meaning-application (car e) (cdr e) r tail?)))
      (if (symbol? e)
          (meaning-reference e r tail?)
          (meaning-quotation e r tail?))))
(define (meaning-quotation v r tail?)
  (CONSTANT v))
(define (meaning-reference n r tail?)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local) (let ((i (cadr kind))
                         (j (cddr kind)))
                     (if (= i 0)
                         (SHALLOW-ARGUMENT-REF j) ; This optimization was omitted in LiSP6a.
                         (DEEP-ARGUMENT-REF i j))))
          ((global) (let ((i (cdr kind)))
                      (CHECKED-GLOBAL-REF i n)))
          ((predefined) (let ((i (cdr kind))) (PREDEFINED i))))
        (static-wrong "no such variable" n))))
(define (meaning-alternative ec et ef r tail?)
  (let ((mc (meaning ec r #f)) ; the condition is definitely NOT in tail position
        (mt (meaning et r tail?))
        (mf (meaning ef r tail?)))
    (ALTERNATIVE mc mt mf)))
(define (meaning-sequence e* r tail?)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (meaning*-multiple-sequence (car e*) (cdr e*) r tail?)
          (meaning (car e*) r tail?))
      (static-wrong "illegal syntax: (begin)")))
(define (meaning*-multiple-sequence e e* r tail?)
  (let ((m (meaning e r #f))
        (m* (meaning-sequence e* r tail?)))
    (SEQUENCE m m*)))
(define (meaning-assignment n e r tail?)
  (let ((m (meaning e r #f))
        (kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local) (let ((i (cadr kind))
                         (j (cddr kind)))
                     (if (= i 0)
                         (SHALLOW-ARGUMENT-SET! j m)
                         (DEEP-ARGUMENT-SET! i j m))))
          ((global) (let ((i (cdr kind)))
                      (GLOBAL-SET! i m)))
          ((predefined) (static-wrong "immutable predefined variable" n)))
        (static-wrong "no such variable" n))))
(define (meaning-abstraction nn* e* r tail?)
  (let next-parameter ((n* nn*) (accumulator '()))
    (cond ((pair? n*) (next-parameter (cdr n*) (cons (car n*) accumulator)))
          ((null? n*) (meaning-fix-abstraction nn* e* r tail?))
          (else (meaning-dotted-abstraction (reverse accumulator) n* e* r tail?)))))
(define (meaning-fix-abstraction n* e* r tail?)
  (let* ((arity (length n*))
         (r2 (r-extend* r n*))
         (m* (meaning-sequence e* r2 #t)))
    (FIX-CLOSURE m* arity)))
(define (meaning-dotted-abstraction n n* e* r tail?)
  (let* ((arity (length n*))
         (r2 (r-extend* r (append n* (list n))))
         (m* (meaning-sequence e* r2 #t)))
    (NARY-CLOSURE m* arity)))
(define (listify! v* arity)
  (let loop ((index (- (activation-frame-argument-length v*) 1)) ; the desired index is the last box in the set
             (result '()))
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1)) result)))))
(define (meaning-application e e* r tail?)
  (cond ((and (symbol? e)
              (let ((kind (compute-kind r e)))
                (and (pair? kind)
                     (eq? 'predefined (car kind))
                     (let ((desc (get-description e)))
                       (and desc
                            (eq? 'function (car desc))
                            (or (= (cddr desc) (length e*))
                                (static-wrong "incorrect arity for primitive" e)))))))
         (meaning-primitive-application e e* r tail?))
        ((and (pair? e)
              (eq? 'lambda (car e)))
         (meaning-closed-application e e* r tail?))
        (else (meaning-regular-application e e* r tail?))))
(define (meaning-regular-application e e* r tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r (length e*) #f)))
    (if tail? (TR-REGULAR-CALL m m*) (REGULAR-CALL m m*))))
(define (meaning* e* r size tail?)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size tail?)
      (meaning-no-arguments r size tail?)))
(define (meaning-some-arguments e e* r size tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r size tail?))
        (rank (- size (+ (length e*) 1))))
    (STORE-ARGUMENT m m* rank)))
(define (meaning-no-arguments r size tail?)
  (ALLOCATE-FRAME size))
(define (meaning-closed-application e ee* r tail?)
  (let ((nn* (cadr e)))
    (let next-parameter ((n* nn*) (e* ee*) (accumulator '()))
      (cond ((pair? n*)
             (if (pair? e*)
                 (next-parameter (cdr n*) (cdr e*) (cons (car n*) accumulator))
                 (static-wrong "too few arguments" e ee*)))
            ((null? n*)
             (if (null? e*)
                 (meaning-fix-closed-application nn* (cddr e) ee* r tail?)
                 (static-wrong "too many arguments" e ee*)))
            (else (meaning-dotted-closed-application (reverse accumulator) n* (cddr e) ee* r tail?))))))
(define (meaning-fix-closed-application n* body e* r tail?)
  (let* ((m* (meaning* e* r (length e*) #f))
         (r2 (r-extend* r n*))
         (mt (meaning-sequence body r2 tail?)))
    (if tail? (TR-FIX-LET m* mt) (FIX-LET m* mt))))
(define (meaning-dotted-closed-application n* n body e* r tail?)
  (let* ((m* (meaning-dotted* e* r (length e*) (length n*) #f))
         (r2 (r-extend* r (append n* (list n))))
         (mt (meaning-sequence body r2 tail?)))
    (if tail? (TR-FIX-LET m* mt) (FIX-LET m* mt))))
(define (meaning-dotted* e* r size arity tail?)
  (if (pair? e*)
      (meaning-some-dotted-arguments (car e*) (cdr e*) r size arity tail?)
      (meaning-no-dotted-arguments r size arity tail?)))
(define (meaning-some-dotted-arguments e e* r size arity tail?)
  (let ((m (meaning e r #f))
        (m* (meaning-dotted* e* r size arity tail?))
        (rank (- size (+ (length e*) 1))))
    (if (< rank arity)
        (STORE-ARGUMENT m m* rank)
        (CONS-ARGUMENT m m* arity))))
(define (meaning-no-dotted-arguments r size arity tail?)
  (ALLOCATE-DOTTED-FRAME arity))
(define (meaning-primitive-application e e* r tail?)
  (let* ((desc (get-description e))
         (address (cadr desc))
         (size (length e*)))
    (case size
      ((0) (CALL0 address))
      ((1) (let ((m1 (meaning (car e*) r #f)))
             (CALL1 address m1)))
      ((2) (let ((m1 (meaning (car e*) r #f))
                 (m2 (meaning (cadr e*) r #f)))
             (CALL2 address m1 m2)))
      ((3) (let ((m1 (meaning (car e*) r #f))
                 (m2 (meaning (cadr e*) r #f))
                 (m3 (meaning (caddr e*) r #f)))
             (CALL3 address m1 m2 m3)))
      (else (meaning-regular-application e e* r tail?)))))

; The virtual machine.
(define (CONSTANT value)
  (lambda () value))
(define (SHALLOW-ARGUMENT-REF i)
  (lambda () (activation-frame-argument *env* i)))
(define (DEEP-ARGUMENT-REF i j)
  (lambda () (deep-fetch *env* i j)))
(define (CHECKED-GLOBAL-REF i n)
  (lambda ()
    (let ((v (global-fetch i)))
      (if (eq? v undefined-value)
          (wrong "uninitialized variable" n)
          v))))
(define (PREDEFINED i)
  (lambda () (predefined-fetch i)))
(define (ALTERNATIVE mc mt mf)
  (lambda () (if (mc) (mt) (mf))))
(define (SHALLOW-ARGUMENT-SET! i m)
  (lambda () (set-activation-frame-argument! *env* i (m))))
(define (DEEP-ARGUMENT-SET! i j m)
  (lambda () (deep-update! *env* i j (m))))
(define (GLOBAL-SET! i m)
  (lambda () (global-update! i (m))))
(define (SEQUENCE m m*)
  (lambda () (m) (m*)))
(define (FIX-CLOSURE m* arity)
  (let ((arity+1 (+ arity 1)))
    (lambda ()
      (define (the-function v* sr)
        (if (= (activation-frame-argument-length v*) arity+1)
            (begin (set! *env* (sr-extend* sr v*)) ; since the m* were evaluated as if they were in the tail position, we are allowed to do this.
                   (m*))
            (wrong "incorrect arity")))
      (make-closure the-function *env*))))
(define (NARY-CLOSURE m* arity)
  (let ((arity+1 (+ arity 1)))
    (lambda ()
      (define (the-function v* sr)
        (if (>= (activation-frame-argument-length v*) arity+1)
            (begin (listify! v* arity)
                   (set! *env* (sr-extend* sr v*))
                   (m*))
            (wrong "incorrect arity")))
      (make-closure the-function *env*))))
(define (TR-REGULAR-CALL m m*)
  (lambda ()
    (let ((f (m)))
      (invoke f (m*)))))
(define (REGULAR-CALL m m*)
  (lambda ()
    (let* ((f (m))
           (v* (m*))
           (sr *env*)
           (result (invoke f v*)))
      (set! *env* sr) ; restore environment. this is optional for tail calls (above), so we just don't do it there.
      result)))
(define (STORE-ARGUMENT m m* rank)
  (lambda () (let* ((v (m))
                    (v* (m*)))
               (set-activation-frame-argument! v* rank v)
               v*)))
(define (ALLOCATE-FRAME size)
  (let ((size+1 (+ size 1)))
    (lambda () (allocate-activation-frame size+1))))
(define (FIX-LET m* mt)
  (lambda ()
    (set! *env* (sr-extend* *env* (m*)))
    (let ((result (mt)))
      (set! *env* (environment-next *env*))
      result)))
(define (TR-FIX-LET m* mt)
  (lambda ()
    (set! *env* (sr-extend* *env* (m*)))
    (mt)))
(define (CONS-ARGUMENT m m* arity)
  (lambda ()
    (let* ((v (m))
           (v* (m*)))
      (set-activation-frame-argument! v* arity
                                      (cons v (activation-frame-argument v* arity)))
      v*)))
(define (ALLOCATE-DOTTED-FRAME arity)
  (let ((arity+1 (+ arity 1)))
    (lambda ()
      (let ((v* (allocate-activation-frame arity+1)))
        (set-activation-frame-argument! v* arity '())
        v*))))
(define (CALL0 address) (lambda () (address)))
(define (CALL1 address m1)
  (lambda () (address (m1))))
(define (CALL2 address m1 m2)
  (lambda () (address (m1) (m2)))) ; no guarantees whether m1 or m2 are evaluated first. use a let* block inside the lambda to enforce that.
(define (CALL3 address m1 m2 m3)
  (lambda () (address (m1) (m2) (m3))))

; The contents of the environment.
(define-syntax definition
  (syntax-rules ()
    ((definition name value)
     (g.init-initialize! 'name value))))
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value 0) (defprimitive0 name value))
    ((defprimitive name value 1) (defprimitive1 name value))
    ((defprimitive name value 2) (defprimitive2 name value))
    ((defprimitive name value 3) (defprimitive3 name value))))
(define-syntax defprimitive0
  (syntax-rules ()
    ((defprimitive0 name value)
     (definition name
       (letrec ((arity+1 (+ 0 1))
                (behavior (lambda (v* sr)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (value)
                                (wrong "incorrect arity" (cons 'name 0))))))
         (description-extend! 'name (cons 'function (cons value 0)))
         (make-closure behavior sr.init))))))
(define-syntax defprimitive1
  (syntax-rules ()
    ((defprimitive1 name value)
     (definition name
       (letrec ((arity+1 (+ 1 1))
                (behavior (lambda (v* sr)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (value (activation-frame-argument v* 0))
                                (wrong "incorrect arity" (cons 'name 1))))))
         (description-extend! 'name (cons 'function (cons value 1)))
         (make-closure behavior sr.init))))))
(define-syntax defprimitive2
  (syntax-rules ()
    ((defprimitive2 name value)
     (definition name
       (letrec ((arity+1 (+ 2 1))
                (behavior (lambda (v* sr)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (value (activation-frame-argument v* 0)
                                       (activation-frame-argument v* 1))
                                (wrong "incorrect arity" (cons 'name 2))))))
         (description-extend! 'name (cons 'function (cons value 2)))
         (make-closure behavior sr.init))))))
(define-syntax defprimitive3
  (syntax-rules ()
    ((defprimitive3 name value)
     (definition name
       (letrec ((arity+1 (+ 3 1))
                (behavior (lambda (v* sr)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (value (activation-frame-argument v* 0)
                                       (activation-frame-argument v* 1)
                                       (activation-frame-argument v* 2))
                                (wrong "incorrect arity" (cons 'name 3))))))
         (description-extend! 'name (cons 'function (cons value 3)))
         (make-closure behavior sr.init))))))
(define-syntax defvariable
  (syntax-rules ()
    ((defvariable name) (g.current-initialize! 'name))))

(definition true #t)
(definition false #f)
(definition nil '())
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive cdr cdr 1)
(defprimitive pair? pair? 1)
(defprimitive symbol? symbol? 1)
(defprimitive eq? eq? 2)
(defprimitive set-car! set-mcar! 2)
(defprimitive set-cdr! set-mcdr! 2)
(defprimitive + + 2)
(defprimitive - - 2)
(defprimitive = = 2)
(defprimitive < < 2)
(defprimitive > > 2)
(defprimitive * * 2)
(defprimitive <= <= 2)
(defprimitive >= >= 2)
(defprimitive remainder remainder 2)
(defprimitive display display 1)
(definition list ((NARY-CLOSURE (SHALLOW-ARGUMENT-REF 0) 0)))
(definition call/cc
  (let* ((arity 1) (arity+1 (+ arity 1)))
    (make-closure
     (lambda (v* sr)
       (if (= arity+1 (activation-frame-argument-length v*))
           (call-with-current-continuation ; since continuations are no longer explicit, we need this.
            (lambda (k)
              (invoke (activation-frame-argument v* 0)
                      (let ((frame (allocate-activation-frame (+ 1 1))))
                        (set-activation-frame-argument!
                         frame 0
                         (make-closure
                          (lambda (values r)
                           (if (= arity+1 (activation-frame-argument-length values))
                               (k (activation-frame-argument values 0))
                               (wrong "incorrect arity" 'continuation)))
                          sr.init))
                        frame))))
           (wrong "incorrect arity" 'call/cc)))
     sr.init)))
(definition apply
  (let* ((arity 2) (arity+1 (+ arity 1)))
    (make-closure
     (lambda (v* sr)
       (if (>= (activation-frame-argument-length v*) arity+1)
           (let* ((proc (activation-frame-argument v* 0))
                  (last-arg-index (- (activation-frame-argument-length v*) 2))
                  (last-arg (activation-frame-argument v* last-arg-index))
                  (size (+ last-arg-index (length last-arg)))
                  (frame (allocate-activation-frame size)))
             (do ((i 1 (+ i 1))) ; for (i = 1; i < last-arg-index; i++)
               ((= i last-arg-index))
               (set-activation-frame-argument! frame (- i 1) (activation-frame-argument v* i))) ; fixed arguments
             (do ((i (- last-arg-index 1) (+ i 1))
                  (last-arg last-arg (cdr last-arg)))
               ((null? last-arg))
               (set-activation-frame-argument! frame i (car last-arg))) ; dotted arguments
             (invoke proc frame))
           (wrong "incorrect arity" 'apply)))
     sr.init)))

(defvariable x)
(defvariable y)
(defvariable z)
(defvariable a)
(defvariable b)
(defvariable c)
(defvariable foo)
(defvariable bar)
(defvariable fib)
(defvariable fact)
(define wrong #f)
(call-with-current-continuation (lambda (k)
                                  (set! wrong (lambda args (display ">>>> EVALUATION ERROR") (newline) (k args)))))
  
(define (LiSP6b)
  (define (toplevel)
    (set! *env* sr.init)
    (display ((meaning (read) r.init #t)))
    (newline)
    (toplevel))
  (toplevel))

(LiSP6b)