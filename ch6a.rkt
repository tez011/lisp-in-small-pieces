#lang racket
; A pre-treating interpreter. Before actual execution, expressions are statically analyzed as best as possible to catch errors early.
; Instead of (eval e r s k), invoke ((meaning e r) sr k). 'e', the program text, and 'r', the set of bindings, are static and known,
; whereas 'sr', the activation records that collectively define memory, and 'k', the final continuation, are dynamic state.
; This is the first step of separating static and dynamic program state, which LiSP4 made no attempt to do.
; As a result, (meaning) must return a (lambda (sr k)) that can be invoked with the dynamic state of the running program to produce a value.
; It also means we are allowed to 'pre-treat' as many values as possible.

; Variable classification.
(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n)))
(define (local-variable? r i n)
  (and (pair? r) ; and C T === if C T #f
       (let scan ((names (car r)) (j 0))
         (cond ((pair? names)
                (if (eq? n (car names))
                    (cons 'local (cons i j))
                    (scan (cdr names) (+ 1 j))))
               ((null? names)
                (local-variable? (cdr r) (+ i 1) n))
               ((eq? n names) (cons 'local (cons i j)))))))
(define (global-variable? g n)
  (let ((var (assq n g)))
    (and (pair? var) (cdr var))))

; The environment and store.
(struct environment (next) #:mutable)
(struct activation-frame environment (arguments) #:mutable)
(define (allocate-activation-frame argsize)
  (activation-frame '()
                    (make-vector argsize)))
(define (activation-frame-argument-length sr)
  (vector-length (activation-frame-arguments sr)))
(define (activation-frame-argument sr i)
  (vector-ref (activation-frame-arguments sr) i))
(define (set-activation-frame-argument! sr i v)
  (vector-set! (activation-frame-arguments sr) i v))

(define r.init '())
(define sr.init '())
(define (r-extend* r n*) (cons n* r))
(define (sr-extend* sr v*)
  (set-environment-next! v* sr)
  v*)
(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j)))
(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v)))

(define g.current '())
(define sg.current (make-vector 100))
(define (g.current-extend! n)
  (let ((level (length g.current)))
    (set! g.current (cons (cons n (cons 'global level)) g.current))
    level))
(define (global-fetch i)
  (vector-ref sg.current i))
(define (global-update! i v)
  (vector-set! sg.current i v))
(define (g.current-initialize! name)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((global) (vector-set! sg.current (cdr kind) undefined-value))
          (else (static-wrong "incorrect redefinition" name))) ; don't allow this function to modify predefined values (which are in sg.init not sg.current anyway)
        (let ((index (g.current-extend! name)))
          (vector-set! sg.current index undefined-value))))
  name)
(define undefined-value '(undefined value))

(define g.init '())
(define sg.init (make-vector 100))
(define (g.init-extend! n)
  (let ((level (length g.init)))
    (set! g.init (cons (cons n (cons 'predefined level)) g.init))
    level))
(define (predefined-fetch i)
  (vector-ref sg.init i))
(define (g.init-initialize! name value)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((predefined) (vector-set! sg.init (cdr kind) value))
          (else (static-wrong "incorrect redefinition" name))) ; don't allow this function to modify global values (which are in sg.current not sg.init anyway)
        (let ((index (g.init-extend! name)))
          (vector-set! sg.init index value))))
  name)

; The descriptor environment. This defines the arity of global immutable functions so those checks can be done at compile time.
(define desc.init '())
(define (description-extend! name description)
  (set! desc.init (cons (cons name description) desc.init))
  name)
(define (get-description name)
  (let ((p (assq name desc.init)))
    (and (pair? p) (cdr p))))

; The interpreter itself.
(define (static-wrong message . culprits)
  (display (cons ('STATIC-ERROR (cons message culprits)))) (newline) ; display the error
  (lambda (sr k) 
    (apply wrong message culprits))) ; and only invoke 'wrong' if the erroneous block is evaluated; if it's skipped, no harm no foul!
(define (meaning e r)
  (if (pair? e)
      (case (car e)
        ((quote) (meaning-quotation (cadr e) r))
        ((if) (meaning-alternative (cadr e) (caddr e) (cadddr e) r))
        ((begin) (meaning-sequence (cdr e) r))
        ((set!) (meaning-assignment (cadr e) (caddr e) r))
        ((lambda) (meaning-abstraction (cadr e) (cddr e) r))
        (else (meaning-application (car e) (cdr e) r)))
      (if (symbol? e)
          (meaning-reference e r)
          (meaning-quotation e r))))

(define (meaning-quotation e r)
  (lambda (sr k)
    (k e))) ; invoke the continuation with the unquoted expression, which is a value.
(define (meaning-alternative ec et ef r)
  (let ((mc (meaning ec r))
        (mt (meaning et r))
        (mf (meaning ef r))) ; pre-treat the condition and the two branches
    (lambda (sr k)
      (mc sr (lambda (vc) ; mc = static meaning of condition; vc = evaluated value of condition
               ((if vc mt mf) sr k))))))

(define (meaning-sequence e* r)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (meaning*-multiple-sequence (car e*) (cdr e*) r)
          (meaning (car e*) r))
      (static-wrong "illegal syntax: begin")))
(define (meaning*-multiple-sequence e e* r)
  (let ((m1 (meaning e r))
        (m2 (meaning-sequence e* r)))
    (lambda (sr k)
      (m1 sr (lambda (void) ; since this is begin, we can ignore whatever 'm1' evaluates to
               (m2 sr k))))))

(define (meaning-reference n r)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)))
             (lambda (sr k)
               (k (deep-fetch sr i j))))) ; Queinnec optimizes the call away when i = 0, but I don't.
          ((global)
           (let ((i (cdr kind)))
             (if (eq? (global-fetch i) undefined-value)
                 (lambda (sr k)
                   (let ((v (global-fetch i))) ; globals could be known at runtime but not compile time
                     (if (eq? v undefined-value)
                         (wrong "uninitialized variable" n)
                         (k v))))
                 (lambda (sr k)
                   (k (global-fetch i))))))
          ((predefined)
           (let* ((i (cdr kind))
                  (value (predefined-fetch i))) ; As a predefined item, we know its value at compile time.
             (lambda (sr k)
               (k value)))))
        (static-wrong "no such variable" n))))

(define (meaning-assignment n e r)
  (let ((m (meaning e r))
        (kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)))
             (lambda (sr k)
               (m sr (lambda (v) (k (deep-update! sr i j v)))))))
          ((global)
           (let ((i (cdr kind)))
             (lambda (sr k)
               (m sr (lambda (v) (k (global-update! i v)))))))
          ((predefined) (static-wrong "illegal assignment of predefined variable" n)))
        (static-wrong "no such variable" n))))


(define (meaning-fix-abstraction n* e* r)
  (let* ((arity (length n*))
         (arity+1 (+ 1 arity))
         (r2 (r-extend* r n*))
         (m* (meaning-sequence e* r2)))
    (lambda (sr k)
      (k (lambda (v* k1)
           (if (= (activation-frame-argument-length v*) arity+1)
               (m* (sr-extend* sr v*) k1)
               (wrong "incorrect arity")))))))
(define (meaning-dotted-abstraction n* n e* r)
  (let* ((arity (length n*))
         (arity+1 (+ 1 arity))
         (r2 (r-extend* r (append n* (list n))))
         (m* (meaning-sequence e* r2)))
    (lambda (sr k)
      (k (lambda (v* k1)
           (if (>= (activation-frame-argument-length v*) arity+1) ; merely allow arity higher than what's defined
               (begin (listify! v* arity)
                      (m* (sr-extend* sr v*) k1))
               (wrong "incorrect arity")))))))
(define (listify! v* arity)
  (let loop ((index (- (activation-frame-argument-length v*) 1)) ; the desired index is the last box in the set
             (result '()))
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1)) result))))) ; build a list in the box, but in reverse order?
(define (meaning-abstraction nn* e* r)
  (let next-parameter ((n* nn*) (accumulator '()))
    (cond ((pair? n*) (next-parameter (cdr n*) (cons (car n*) accumulator)))
          ((null? n*) (meaning-fix-abstraction nn* e* r))
          (else (meaning-dotted-abstraction (reverse accumulator) n* e* r)))))

(define (meaning-application e e* r)
  (cond
    ((and (symbol? e)
          (let ((kind (compute-kind r e)))
            (and (pair? kind)
                 (eq? 'predefined (car kind))
                 (let ((desc (get-description e)))
                   (and desc
                        (eq? 'function (car desc))
                        (if (= (cddr desc) (length e*))
                            (meaning-primitive-application e e* r)
                            (static-wrong "incorrect arity for" e))))))))
    ((and (pair? e)
          (eq? 'lambda (car e)))
     (meaning-closed-application e e* r))
    (else (meaning-regular-application e e* r))))
(define (meaning-primitive-application e e* r)
  (let* ((desc (get-description e))
         (address (cadr desc))
         (size (length e*)))
    (case size ; it is said there are no essential fixed-arity functions with more than three parameters...
      ((0) (lambda (sr k) (k (address))))
      ((1) (let ((m1 (meaning (car e*) r)))
            (lambda (sr k)
              (m1 sr (lambda (v1)
                       (k (address v1)))))))
      ((2) (let ((m1 (meaning (car e*) r))
                 (m2 (meaning (cadr e*) r)))
            (lambda (sr k)
              (m1 sr (lambda (v1)
                       (m2 sr (lambda (v2)
                                (k (address v1 v2)))))))))
      ((3) (let ((m1 (meaning (car e*) r))
                 (m2 (meaning (cadr e*) r))
                 (m3 (meaning (caddr e*) r)))
             (lambda (sr k)
               (m1 sr (lambda (v1)
                        (m2 sr (lambda (v2)
                                 (m3 sr (lambda (v3)
                                          (k (address v1 v2 v3)))))))))))
      (else (meaning-regular-application e e* r)))))
      
(define (meaning-regular-application e e* r)
  (let* ((m (meaning e r))
         (m* (meaning* e* r (length e*))))
    (lambda (sr k)
      (m sr (lambda (f)
              (if (procedure? f)
                  (m* sr (lambda (v*)
                           (f v* k)))
                  (wrong "not a function" f))))))) ; can this be static in the future?
(define (meaning* e* r size)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size)
      (meaning-no-arguments r size)))
(define (meaning-no-arguments r size)
  (let ((size+1 (+ 1 size))) ; the extra slot is for variable arity, specifically an *args parameter like in Python
    (lambda (sr k)
      (let ((v* (allocate-activation-frame size+1))) 
        (k v*)))))
(define (meaning-some-arguments e e* r size)
  (let ((m (meaning e r))
        (m* (meaning* e* r size))
        (rank (- size (+ (length e*) 1)))) ; the position of the 'e' argument
    (lambda (sr k)
      (m sr (lambda (v) ; the value of the 'e' argument
              (m* sr (lambda (v*) ; the value of the following arguments
                       (set-activation-frame-argument! v* rank v)
                       (k v*))))))))
(define (meaning-closed-application e ee* r)
  (let ((nn* (cadr e)))
    (let next-parameter ((n* nn*) (e* ee*) (accumulator '()))
      (cond ((pair? n*)
             (if (pair? e*)
                 (next-parameter (cdr n*) (cdr e*) (cons (car n*) accumulator))
                 (static-wrong "too few arguments" e ee*)))
            ((null? n*)
             (if (null? e*)
                 (meaning-fix-closed-application nn* (cddr e) ee* r)
                 (static-wrong "too many arguments" e ee*)))
            (else (meaning-dotted-closed-application (reverse accumulator) n* (cddr e) ee* r))))))
(define (meaning-fix-closed-application n* body e* r)
  (let* ((m* (meaning* e* r (length e*)))
         (r2 (r-extend* r n*))
         (mt (meaning-sequence body r2)))
    (lambda (sr k)
      (m* sr (lambda (v*) ; first evaluate the arguments
               (mt (sr-extend* sr v*) k)))))) ; extend the store with bindings to those values, then evaluate the body
(define (meaning-dotted-closed-application n* n body e* r)
  (let* ((m* (meaning-dotted* e* r (length e*) (length n*))) ; this is the only difference
         (r2 (r-extend* r (append n* (list n))))
         (mt (meaning-sequence body r2)))
    (lambda (sr k)
      (m* sr (lambda (v*)
               (mt (sr-extend* sr v*) k))))))
(define (meaning-dotted* e* r size arity)
  (if (pair? e*)
      (meaning-some-dotted-arguments (car e*) (cdr e*) r size arity)
      (meaning-no-dotted-arguments r size arity)))
(define (meaning-some-dotted-arguments e e* r size arity)
  (let ((m (meaning e r))
        (m* (meaning-dotted* e* r size arity))
        (rank (- size (+ (length e*) 1))))
    (if (< rank arity)
        (lambda (sr k) ; this is identical to the evaluation procedure in meaning-some-arguments
          (m sr (lambda (v)
                  (m* sr (lambda (v*)
                           (set-activation-frame-argument! v* rank v)
                           (k v*))))))
        (lambda (sr k)
          (m sr (lambda (v)
                  (m* sr (lambda (v*)
                           (set-activation-frame-argument! v*
                                                           arity
                                                           (cons v (activation-frame-argument v* arity)))
                           (k v*)))))))))
(define (meaning-no-dotted-arguments r size arity)
  (let ((arity+1 (+ 1 arity)))
    (lambda (sr k)
      (let ((v* (allocate-activation-frame arity+1)))
        (set-activation-frame-argument! v* arity '())
        (k v*)))))


; The contents of the environment.
(define-syntax definition
  (syntax-rules ()
    ((definition name value)
     (g.init-initialize! 'name value))))
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value 0) (defprimitive0 name value))
    ((defprimitive name value 1) (defprimitive1 name value))
    ((defprimitive name value 2) (defprimitive2 name value))
    ((defprimitive name value 3) (defprimitive3 name value))))
(define-syntax defprimitive0
  (syntax-rules ()
    ((defprimitive0 name value)
     (definition name
       (letrec ((arity+1 (+ 0 1))
                (behavior (lambda (v* k)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (k (value))
                                (wrong "incorrect arity" (cons 'name 0))))))
         (description-extend! 'name (cons 'function (cons value 0)))
         behavior)))))
(define-syntax defprimitive1
  (syntax-rules ()
    ((defprimitive1 name value)
     (definition name
       (letrec ((arity+1 (+ 1 1))
                (behavior (lambda (v* k)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (k (value (activation-frame-argument v* 0)))
                                (wrong "incorrect arity" (cons 'name 1))))))
         (description-extend! 'name (cons 'function (cons value 1)))
         behavior)))))
(define-syntax defprimitive2
  (syntax-rules ()
    ((defprimitive2 name value)
     (definition name
       (letrec ((arity+1 (+ 2 1))
                (behavior (lambda (v* k)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (k (value (activation-frame-argument v* 0)
                                          (activation-frame-argument v* 1)))
                                (wrong "incorrect arity" (cons 'name 2))))))
         (description-extend! 'name (cons 'function (cons value 2)))
         behavior)))))
(define-syntax defprimitive3
  (syntax-rules ()
    ((defprimitive3 name value)
     (definition name
       (letrec ((arity+1 (+ 3 1))
                (behavior (lambda (v* k)
                            (if (= (activation-frame-argument-length v*) arity+1)
                                (k (value (activation-frame-argument v* 0)
                                          (activation-frame-argument v* 1)
                                          (activation-frame-argument v* 2)))
                                (wrong "incorrect arity" (cons 'name 3))))))
         (description-extend! 'name (cons 'function (cons value 3)))
         behavior)))))

(definition true #t)
(definition false #f)
(definition nil '())
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive cdr cdr 1)
(defprimitive pair? pair? 1)
(defprimitive symbol? symbol? 1)
(defprimitive eq? eq? 2)
(defprimitive set-car! set-mcar! 2)
(defprimitive set-cdr! set-mcdr! 2)
(defprimitive + + 2)
(defprimitive - - 2)
(defprimitive = = 2)
(defprimitive < < 2)
(defprimitive > > 2)
(defprimitive * * 2)
(defprimitive <= <= 2)
(defprimitive >= >= 2)
(defprimitive remainder remainder 2)
(defprimitive display display 1)
(definition call/cc
  (let* ((arity 1) (arity+1 (+ 1 arity)))
    (lambda (v* k)
      (if (= arity+1 (activation-frame-argument-length v*))
          ((activation-frame-argument v* 0)
           (let ((frame (allocate-activation-frame (+ 1 1))))
             (set-activation-frame-argument! ; replace the current continuation in its frame with the parameter to call/cc.
              frame 0
              (lambda (values kk)
                (if (= arity+1 (activation-frame-argument-length values))
                    (k (activation-frame-argument values 0))
                    (wrong "incorrect arity" 'continuation))))
             frame)
           k)
          (wrong "incorrect arity" 'call/cc)))))


(define wrong #f)
(call-with-current-continuation (lambda (k)
                                  (set! wrong (lambda args (display ">>>> EVALUATION ERROR") (newline) (k args)))))

(define (LiSP6a)
  (define (compile e) (meaning e r.init))  ; returns 'c', the semantic meaning of the expression, if valid
  (define (execute c) (c sr.init (lambda (v) (display v) (newline)))) ; evaluates 'c' to 'v'
  (define (toplevel)
    (execute (compile (read)))
    (toplevel))
  (toplevel))

(LiSP6a)